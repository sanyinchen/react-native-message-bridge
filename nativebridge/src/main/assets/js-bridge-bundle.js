/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./BatchedBridge/BatchedBridge.js":
/*!****************************************!*\
  !*** ./BatchedBridge/BatchedBridge.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n\nvar MessageQueue = __webpack_require__(/*! ./MessageQueue */ \"./BatchedBridge/MessageQueue.js\");\n\nvar BatchedBridge = new MessageQueue(); // Wire up the batched bridge on the global object so that we can call into it.\n// Ideally, this would be the inverse relationship. I.e. the native environment\n// provides this global directly with its script embedded. Then this module\n// would export it. A possible fix would be to trim the dependencies in\n// MessageQueue to its minimal features and embed that in the native runtime.\n\nObject.defineProperty(global, '__fbBatchedBridge', {\n  configurable: true,\n  value: BatchedBridge\n});\nmodule.exports = BatchedBridge;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./BatchedBridge/BatchedBridge.js?");

/***/ }),

/***/ "./BatchedBridge/MessageQueue.js":
/*!***************************************!*\
  !*** ./BatchedBridge/MessageQueue.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ErrorUtils = __webpack_require__(/*! ../polyfills/error-guard */ \"./polyfills/error-guard.js\");\n\nvar Systrace = __webpack_require__(/*! ../Performance/Systrace */ \"./Performance/Systrace.js\"); // const deepFreezeAndThrowOnMutationInDev = require('deepFreezeAndThrowOnMutationInDev');\n\n\nvar invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar stringifySafe = __webpack_require__(/*! ../polyfills/stringifySafe */ \"./polyfills/stringifySafe.js\");\n\nvar TO_JS = 0;\nvar TO_NATIVE = 1;\nvar MODULE_IDS = 0;\nvar METHOD_IDS = 1;\nvar PARAMS = 2;\nvar MIN_TIME_BETWEEN_FLUSHES_MS = 5; // eslint-disable-next-line no-bitwise\n\nvar TRACE_TAG_REACT_APPS = 1 << 17;\nvar DEBUG_INFO_LIMIT = 32;\n\nvar MessageQueue = /*#__PURE__*/function () {\n  function MessageQueue() {\n    _classCallCheck(this, MessageQueue);\n\n    this._lazyCallableModules = {};\n    this._queue = [[], [], [], 0];\n    this._successCallbacks = {};\n    this._failureCallbacks = {};\n    this._callID = 0;\n    this._lastFlush = 0;\n    this._eventLoopStartTime = Date.now();\n    this._immediatesCallback = null;\n\n    if (__DEV__) {\n      this._debugInfo = {};\n      this._remoteModuleTable = {};\n      this._remoteMethodTable = {};\n    }\n\n    this.callFunctionReturnFlushedQueue = this.callFunctionReturnFlushedQueue.bind(this);\n    this.callFunctionReturnResultAndFlushedQueue = this.callFunctionReturnResultAndFlushedQueue.bind(this);\n    this.flushedQueue = this.flushedQueue.bind(this);\n    this.invokeCallbackAndReturnFlushedQueue = this.invokeCallbackAndReturnFlushedQueue.bind(this);\n  }\n  /**\n   * Public APIs\n   */\n\n\n  _createClass(MessageQueue, [{\n    key: \"callFunctionReturnFlushedQueue\",\n    value: function callFunctionReturnFlushedQueue(module, method, args) {\n      var _this = this;\n\n      this.__guard(function () {\n        _this.__callFunction(module, method, args);\n      });\n\n      return this.flushedQueue();\n    }\n  }, {\n    key: \"callFunctionReturnResultAndFlushedQueue\",\n    value: function callFunctionReturnResultAndFlushedQueue(module, method, args) {\n      var _this2 = this;\n\n      var result;\n\n      this.__guard(function () {\n        result = _this2.__callFunction(module, method, args);\n      });\n\n      return [result, this.flushedQueue()];\n    }\n  }, {\n    key: \"invokeCallbackAndReturnFlushedQueue\",\n    value: function invokeCallbackAndReturnFlushedQueue(cbID, args) {\n      var _this3 = this;\n\n      this.__guard(function () {\n        _this3.__invokeCallback(cbID, args);\n      });\n\n      return this.flushedQueue();\n    }\n  }, {\n    key: \"flushedQueue\",\n    value: function flushedQueue() {\n      var _this4 = this;\n\n      this.__guard(function () {\n        _this4.__callImmediates();\n      });\n\n      var queue = this._queue;\n      this._queue = [[], [], [], this._callID];\n      return queue[0].length ? queue : null;\n    }\n  }, {\n    key: \"getEventLoopRunningTime\",\n    value: function getEventLoopRunningTime() {\n      return Date.now() - this._eventLoopStartTime;\n    }\n  }, {\n    key: \"registerCallableModule\",\n    value: function registerCallableModule(name, module) {\n      this._lazyCallableModules[name] = function () {\n        return module;\n      };\n    }\n  }, {\n    key: \"registerLazyCallableModule\",\n    value: function registerLazyCallableModule(name, factory) {\n      var module;\n      var getValue = factory;\n\n      this._lazyCallableModules[name] = function () {\n        if (getValue) {\n          module = getValue();\n          getValue = null;\n        }\n\n        return module;\n      };\n    }\n  }, {\n    key: \"getCallableModule\",\n    value: function getCallableModule(name) {\n      var getValue = this._lazyCallableModules[name];\n      return getValue ? getValue() : null;\n    }\n  }, {\n    key: \"enqueueNativeCall\",\n    value: function enqueueNativeCall(moduleID, methodID, params, onFail, onSucc) {\n      if (onFail || onSucc) {\n        if (__DEV__) {\n          this._debugInfo[this._callID] = [moduleID, methodID];\n\n          if (this._callID > DEBUG_INFO_LIMIT) {\n            delete this._debugInfo[this._callID - DEBUG_INFO_LIMIT];\n          }\n        } // Encode callIDs into pairs of callback identifiers by shifting left and using the rightmost bit\n        // to indicate fail (0) or success (1)\n        // eslint-disable-next-line no-bitwise\n\n\n        onFail && params.push(this._callID << 1); // eslint-disable-next-line no-bitwise\n\n        onSucc && params.push(this._callID << 1 | 1);\n        this._successCallbacks[this._callID] = onSucc;\n        this._failureCallbacks[this._callID] = onFail;\n      }\n\n      if (__DEV__) {\n        global.nativeTraceBeginAsyncFlow && global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, 'native', this._callID);\n      }\n\n      this._callID++;\n\n      this._queue[MODULE_IDS].push(moduleID);\n\n      this._queue[METHOD_IDS].push(methodID);\n\n      if (__DEV__) {\n        // Validate that parameters passed over the bridge are\n        // folly-convertible.  As a special case, if a prop value is a\n        // function it is permitted here, and special-cased in the\n        // conversion.\n        var isValidArgument = function isValidArgument(val) {\n          var t = _typeof(val);\n\n          if (t === 'undefined' || t === 'null' || t === 'boolean' || t === 'string') {\n            return true;\n          }\n\n          if (t === 'number') {\n            return isFinite(val);\n          }\n\n          if (t === 'function' || t !== 'object') {\n            return false;\n          }\n\n          if (Array.isArray(val)) {\n            return val.every(isValidArgument);\n          }\n\n          for (var k in val) {\n            if (typeof val[k] !== 'function' && !isValidArgument(val[k])) {\n              return false;\n            }\n          }\n\n          return true;\n        }; // Replacement allows normally non-JSON-convertible values to be\n        // seen.  There is ambiguity with string values, but in context,\n        // it should at least be a strong hint.\n\n\n        var replacer = function replacer(key, val) {\n          var t = _typeof(val);\n\n          if (t === 'function') {\n            return '<<Function ' + val.name + '>>';\n          } else if (t === 'number' && !isFinite(val)) {\n            return '<<' + val.toString() + '>>';\n          } else {\n            return val;\n          }\n        }; // Note that JSON.stringify\n\n\n        invariant(isValidArgument(params), '%s is not usable as a native method argument', JSON.stringify(params, replacer)); // The params object should not be mutated after being queued\n        // deepFreezeAndThrowOnMutationInDev((params: any));\n      }\n\n      this._queue[PARAMS].push(params);\n\n      var now = Date.now();\n\n      if (global.nativeFlushQueueImmediate && now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {\n        var queue = this._queue;\n        this._queue = [[], [], [], this._callID];\n        this._lastFlush = now;\n        global.nativeFlushQueueImmediate(queue);\n      }\n\n      Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);\n\n      if (__DEV__ && this.__spy && isFinite(moduleID)) {\n        this.__spy({\n          type: TO_NATIVE,\n          module: this._remoteModuleTable[moduleID],\n          method: this._remoteMethodTable[moduleID][methodID],\n          args: params\n        });\n      } else if (this.__spy) {\n        this.__spy({\n          type: TO_NATIVE,\n          module: moduleID + '',\n          method: methodID,\n          args: params\n        });\n      }\n    }\n  }, {\n    key: \"createDebugLookup\",\n    value: function createDebugLookup(moduleID, name, methods) {\n      if (__DEV__) {\n        this._remoteModuleTable[moduleID] = name;\n        this._remoteMethodTable[moduleID] = methods;\n      }\n    } // For JSTimers to register its callback. Otherwise a circular dependency\n    // between modules is introduced. Note that only one callback may be\n    // registered at a time.\n\n  }, {\n    key: \"setImmediatesCallback\",\n    value: function setImmediatesCallback(fn) {\n      this._immediatesCallback = fn;\n    }\n    /**\n     * Private methods\n     */\n\n  }, {\n    key: \"__guard\",\n    value: function __guard(fn) {\n      if (this.__shouldPauseOnThrow()) {\n        fn();\n      } else {\n        try {\n          fn();\n        } catch (error) {\n          ErrorUtils.reportFatalError(error);\n        }\n      }\n    } // MessageQueue installs a global handler to catch all exceptions where JS users can register their own behavior\n    // This handler makes all exceptions to be propagated from inside MessageQueue rather than by the VM at their origin\n    // This makes stacktraces to be placed at MessageQueue rather than at where they were launched\n    // The parameter DebuggerInternal.shouldPauseOnThrow is used to check before catching all exceptions and\n    // can be configured by the VM or any Inspector\n\n  }, {\n    key: \"__shouldPauseOnThrow\",\n    value: function __shouldPauseOnThrow() {\n      return (// $FlowFixMe\n        typeof DebuggerInternal !== 'undefined' && DebuggerInternal.shouldPauseOnThrow === true // eslint-disable-line no-undef\n\n      );\n    }\n  }, {\n    key: \"__callImmediates\",\n    value: function __callImmediates() {\n      Systrace.beginEvent('JSTimers.callImmediates()');\n\n      if (this._immediatesCallback != null) {\n        this._immediatesCallback();\n      }\n\n      Systrace.endEvent();\n    }\n  }, {\n    key: \"__callFunction\",\n    value: function __callFunction(module, method, args) {\n      this._lastFlush = Date.now();\n      this._eventLoopStartTime = this._lastFlush;\n\n      if (__DEV__ || this.__spy) {\n        Systrace.beginEvent(\"\".concat(module, \".\").concat(method, \"(\").concat(stringifySafe(args), \")\"));\n      } else {\n        Systrace.beginEvent(\"\".concat(module, \".\").concat(method, \"(...)\"));\n      }\n\n      if (this.__spy) {\n        this.__spy({\n          type: TO_JS,\n          module: module,\n          method: method,\n          args: args\n        });\n      }\n\n      var moduleMethods = this.getCallableModule(module);\n      invariant(!!moduleMethods, 'Module %s is not a registered callable module (calling %s)', module, method);\n      invariant(!!moduleMethods[method], 'Method %s does not exist on module %s', method, module);\n      var result = moduleMethods[method].apply(moduleMethods, args);\n      Systrace.endEvent();\n      return result;\n    }\n  }, {\n    key: \"__invokeCallback\",\n    value: function __invokeCallback(cbID, args) {\n      this._lastFlush = Date.now();\n      this._eventLoopStartTime = this._lastFlush; // The rightmost bit of cbID indicates fail (0) or success (1), the other bits are the callID shifted left.\n      // eslint-disable-next-line no-bitwise\n\n      var callID = cbID >>> 1; // eslint-disable-next-line no-bitwise\n\n      var isSuccess = cbID & 1;\n      var callback = isSuccess ? this._successCallbacks[callID] : this._failureCallbacks[callID];\n\n      if (__DEV__) {\n        var debug = this._debugInfo[callID];\n\n        var _module = debug && this._remoteModuleTable[debug[0]];\n\n        var method = debug && this._remoteMethodTable[debug[0]][debug[1]];\n\n        if (!callback) {\n          var errorMessage = \"Callback with id \".concat(cbID, \": \").concat(_module, \".\").concat(method, \"() not found\");\n\n          if (method) {\n            errorMessage = \"The callback \".concat(method, \"() exists in module \").concat(_module, \", \") + 'but only one callback may be registered to a function in a native module.';\n          }\n\n          invariant(callback, errorMessage);\n        }\n\n        var profileName = debug ? '<callback for ' + _module + '.' + method + '>' : cbID;\n\n        if (callback && this.__spy) {\n          this.__spy({\n            type: TO_JS,\n            module: null,\n            method: profileName,\n            args: args\n          });\n        }\n\n        Systrace.beginEvent(\"MessageQueue.invokeCallback(\".concat(profileName, \", \").concat(stringifySafe(args), \")\"));\n      }\n\n      if (!callback) {\n        return;\n      }\n\n      delete this._successCallbacks[callID];\n      delete this._failureCallbacks[callID];\n      callback.apply(void 0, _toConsumableArray(args));\n\n      if (__DEV__) {\n        Systrace.endEvent();\n      }\n    }\n  }], [{\n    key: \"spy\",\n    value: function spy(spyOrToggle) {\n      if (spyOrToggle === true) {\n        MessageQueue.prototype.__spy = function (info) {\n          console.log(\"\".concat(info.type === TO_JS ? 'N->JS' : 'JS->N', \" : \") + \"\".concat(info.module ? info.module + '.' : '').concat(info.method) + \"(\".concat(JSON.stringify(info.args), \")\"));\n        };\n      } else if (spyOrToggle === false) {\n        MessageQueue.prototype.__spy = null;\n      } else {\n        MessageQueue.prototype.__spy = spyOrToggle;\n      }\n    }\n  }]);\n\n  return MessageQueue;\n}();\n\nmodule.exports = MessageQueue;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./BatchedBridge/MessageQueue.js?");

/***/ }),

/***/ "./BatchedBridge/NativeModules.js":
/*!****************************************!*\
  !*** ./BatchedBridge/NativeModules.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nglobal.__DEV__ = true;\n\nvar BatchedBridge = __webpack_require__(/*! ./BatchedBridge */ \"./BatchedBridge/BatchedBridge.js\");\n\nvar invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nfunction genModule(config, moduleID) {\n  if (!config) {\n    return null;\n  }\n\n  var _config = _slicedToArray(config, 5),\n      moduleName = _config[0],\n      constants = _config[1],\n      methods = _config[2],\n      promiseMethods = _config[3],\n      syncMethods = _config[4];\n\n  invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), \"Module name prefixes should've been stripped by the native side \" + \"but wasn't for \" + moduleName);\n\n  if (!constants && !methods) {\n    // Module contents will be filled in lazily later\n    return {\n      name: moduleName\n    };\n  }\n\n  var module = {};\n  methods && methods.forEach(function (methodName, methodID) {\n    var isPromise = promiseMethods && arrayContains(promiseMethods, methodID);\n    var isSync = syncMethods && arrayContains(syncMethods, methodID);\n    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');\n    var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n    module[methodName] = genMethod(moduleID, methodID, methodType);\n  });\n  Object.assign(module, constants);\n\n  if (module.getConstants == null) {\n    module.getConstants = function () {\n      return constants;\n    };\n  } else {\n    console.warn(\"Unable to define method 'getConstants()' on NativeModule '\".concat(moduleName, \"'. NativeModule '\").concat(moduleName, \"' already has a constant or method called 'getConstants'. Please remove it.\"));\n  }\n\n  if (__DEV__) {\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\n  }\n\n  return {\n    name: moduleName,\n    module: module\n  };\n} // export this method as a global so we can call it from native\n\n\nglobal.__fbGenNativeModule = genModule;\n\nfunction loadModule(name, moduleID) {\n  invariant(global.nativeRequireModuleConfig, \"Can't lazily create module without nativeRequireModuleConfig\");\n  var config = global.nativeRequireModuleConfig(name);\n  var info = genModule(config, moduleID);\n  return info && info.module;\n}\n\nfunction genMethod(moduleID, methodID, type) {\n  var fn = null;\n\n  if (type === 'promise') {\n    fn = function fn() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return new Promise(function (resolve, reject) {\n        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, function (data) {\n          return resolve(data);\n        }, function (errorData) {\n          return reject(createErrorFromErrorData(errorData));\n        });\n      });\n    };\n  } else if (type === 'sync') {\n    fn = function fn() {\n      if (__DEV__) {\n        invariant(global.nativeCallSyncHook, 'Calling synchronous methods on native ' + 'modules is not supported in Chrome.\\n\\n Consider providing alternative ' + 'methods to expose this method in debug mode, e.g. by exposing constants ' + 'ahead-of-time.');\n      }\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return global.nativeCallSyncHook(moduleID, methodID, args);\n    };\n  } else {\n    fn = function fn() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var lastArg = args.length > 0 ? args[args.length - 1] : null;\n      var secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n      var hasSuccessCallback = typeof lastArg === 'function';\n      var hasErrorCallback = typeof secondLastArg === 'function';\n      hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');\n      var onSuccess = hasSuccessCallback ? lastArg : null;\n      var onFail = hasErrorCallback ? secondLastArg : null;\n      var callbackCount = hasSuccessCallback + hasErrorCallback;\n      args = args.slice(0, args.length - callbackCount);\n      BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);\n    };\n  }\n\n  fn.type = type;\n  return fn;\n}\n\nfunction arrayContains(array, value) {\n  return array.indexOf(value) !== -1;\n}\n\nfunction createErrorFromErrorData(errorData) {\n  var _ref = errorData || {},\n      message = _ref.message,\n      extraErrorInfo = _objectWithoutProperties(_ref, [\"message\"]);\n\n  var error = new Error(message);\n  error.framesToPop = 1;\n  return Object.assign(error, extraErrorInfo);\n}\n\nvar NativeModules = {};\n\nif (global.nativeModuleProxy) {\n  NativeModules = global.nativeModuleProxy;\n} else if (!global.nativeExtensions) {\n  var bridgeConfig = global.__fbBatchedBridgeConfig;\n  invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');\n\n  var defineLazyObjectProperty = __webpack_require__(/*! ../polyfills/defineLazyObjectProperty */ \"./polyfills/defineLazyObjectProperty.js\");\n\n  (bridgeConfig.remoteModuleConfig || []).forEach(function (config, moduleID) {\n    // Initially this config will only contain the module name when running in JSC. The actual\n    // configuration of the module will be lazily loaded.\n    var info = genModule(config, moduleID);\n\n    if (!info) {\n      return;\n    }\n\n    if (info.module) {\n      NativeModules[info.name] = info.module;\n    } // If there's no module config, define a lazy getter\n    else {\n        defineLazyObjectProperty(NativeModules, info.name, {\n          get: function get() {\n            return loadModule(info.name, moduleID);\n          }\n        });\n      }\n  });\n}\n\nmodule.exports = NativeModules;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./BatchedBridge/NativeModules.js?");

/***/ }),

/***/ "./Core/Devtools/parseErrorStack.js":
/*!******************************************!*\
  !*** ./Core/Devtools/parseErrorStack.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n\nfunction parseErrorStack(e) {\n  if (!e || !e.stack) {\n    return [];\n  }\n  /* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an\n   * error found when Flow v0.54 was deployed. To see the error delete this\n   * comment and run Flow. */\n\n\n  var stacktraceParser = __webpack_require__(/*! stacktrace-parser */ \"./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js\");\n\n  var stack = Array.isArray(e.stack) ? e.stack : stacktraceParser.parse(e.stack);\n  var framesToPop = typeof e.framesToPop === 'number' ? e.framesToPop : 0;\n\n  while (framesToPop--) {\n    stack.shift();\n  }\n\n  return stack;\n}\n\nmodule.exports = parseErrorStack;\n\n//# sourceURL=webpack:///./Core/Devtools/parseErrorStack.js?");

/***/ }),

/***/ "./Core/Timers/JSTimers.js":
/*!*********************************!*\
  !*** ./Core/Timers/JSTimers.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n\nvar Platform = __webpack_require__(/*! ../../Utilities/Platform */ \"./Utilities/Platform.js\");\n\nvar Systrace = __webpack_require__(/*! ../../Performance/Systrace */ \"./Performance/Systrace.js\");\n\nvar invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar _require = __webpack_require__(/*! ../../BatchedBridge/NativeModules */ \"./BatchedBridge/NativeModules.js\"),\n    Timing = _require.Timing;\n\nvar BatchedBridge = __webpack_require__(/*! ../../BatchedBridge/BatchedBridge */ \"./BatchedBridge/BatchedBridge.js\");\n\nvar _performanceNow = null;\n\nfunction performanceNow() {\n  if (!_performanceNow) {\n    /* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an\n     * error found when Flow v0.54 was deployed. To see the error delete this\n     * comment and run Flow. */\n    _performanceNow = __webpack_require__(/*! fbjs/lib/performanceNow */ \"./node_modules/fbjs/lib/performanceNow.js\");\n  }\n\n  return _performanceNow();\n}\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\n\n// These timing constants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nvar FRAME_DURATION = 1000 / 60;\nvar IDLE_CALLBACK_FRAME_DEADLINE = 1;\nvar MAX_TIMER_DURATION_MS = 60 * 1000;\nvar IS_ANDROID = Platform.OS === 'android';\nvar ANDROID_LONG_TIMER_MESSAGE = 'Setting a timer for a long period of time, i.e. multiple minutes, is a ' + 'performance and correctness issue on Android as it keeps the timer ' + 'module awake, and timers can only be called when the app is in the foreground. ' + 'See https://github.com/facebook/react-native/issues/12981 for more info.'; // Parallel arrays\n\nvar callbacks = [];\nvar types = [];\nvar timerIDs = [];\nvar immediates = [];\nvar requestIdleCallbacks = [];\nvar requestIdleCallbackTimeouts = {};\nvar identifiers = [];\nvar GUID = 1;\nvar errors = null;\nvar hasEmittedTimeDriftWarning = false; // Returns a free index if one is available, and the next consecutive index otherwise.\n\nfunction _getFreeIndex() {\n  var freeIndex = timerIDs.indexOf(null);\n\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n\n  return freeIndex;\n}\n\nfunction _allocateCallback(func, type) {\n  var id = GUID++;\n\n  var freeIndex = _getFreeIndex();\n\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n\n  if (__DEV__) {\n    var parseErrorStack = __webpack_require__(/*! ../Devtools/parseErrorStack */ \"./Core/Devtools/parseErrorStack.js\");\n\n    var error = new Error();\n    error.framesToPop = 1;\n    var stack = parseErrorStack(error);\n\n    if (stack) {\n      identifiers[freeIndex] = stack.shift();\n    }\n  }\n\n  return id;\n}\n/**\n * Calls the callback associated with the ID. Also unregister that callback\n * if it was a one time timer (setTimeout), and not unregister it if it was\n * recurring (setInterval).\n */\n\n\nfunction _callTimer(timerID, frameTime, didTimeout) {\n  /* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an\n   * error found when Flow v0.54 was deployed. To see the error delete this\n   * comment and run Flow. */\n  __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\")(timerID <= GUID, 'Tried to call timer with ID %s but no such timer exists.', timerID); // timerIndex of -1 means that no timer with that ID exists. There are\n  // two situations when this happens, when a garbage timer ID was given\n  // and when a previously existing timer was deleted before this callback\n  // fired. In both cases we want to ignore the timer id, but in the former\n  // case we warn as well.\n\n\n  var timerIndex = timerIDs.indexOf(timerID);\n\n  if (timerIndex === -1) {\n    return;\n  }\n\n  var type = types[timerIndex];\n  var callback = callbacks[timerIndex];\n\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    var identifier = identifiers[timerIndex] || {};\n    Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);\n  } // Clear the metadata\n\n\n  if (type === 'setTimeout' || type === 'setImmediate' || type === 'requestAnimationFrame' || type === 'requestIdleCallback') {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (type === 'setTimeout' || type === 'setInterval' || type === 'setImmediate') {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(performanceNow());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function timeRemaining() {\n          // TODO: Optimisation: allow running for longer than one frame if\n          // there are no pending JS calls on the bridge from native. This\n          // would require a way to check the bridge queue synchronously.\n          return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n        },\n        didTimeout: !!didTimeout\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    // Don't rethrow so that we can run all timers.\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n/**\n * Performs a single pass over the enqueued immediates. Returns whether\n * more immediates are queued up (can be used as a condition a while loop).\n */\n\n\nfunction _callImmediatesPass() {\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  } // The main reason to extract a single pass is so that we can track\n  // in the system trace\n\n\n  if (immediates.length > 0) {\n    var passImmediates = immediates.slice();\n    immediates = []; // Use for loop rather than forEach as per @vjeux's advice\n    // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n\n    for (var i = 0; i < passImmediates.length; ++i) {\n      _callTimer(passImmediates[i], 0);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n\n  return immediates.length > 0;\n}\n\nfunction _clearIndex(i) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n  identifiers[i] = null;\n}\n\nfunction _freeCallback(timerID) {\n  // timerIDs contains nulls after timers have been removed;\n  // ignore nulls upfront so indexOf doesn't find them\n  if (timerID == null) {\n    return;\n  }\n\n  var index = timerIDs.indexOf(timerID); // See corresponding comment in `callTimers` for reasoning behind this\n\n  if (index !== -1) {\n    _clearIndex(index);\n\n    var type = types[index];\n\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      Timing.deleteTimer(timerID);\n    }\n  }\n}\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\n\nvar JSTimers = {\n  /**\n   * @param {function} func Callback to be invoked after `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setTimeout: function setTimeout(func, duration) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(ANDROID_LONG_TIMER_MESSAGE + '\\n' + '(Saw setTimeout with duration ' + duration + 'ms)');\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setTimeout');\n\n    Timing.createTimer(id, duration || 0, Date.now(),\n    /* recurring */\n    false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setInterval: function setInterval(func, duration) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(ANDROID_LONG_TIMER_MESSAGE + '\\n' + '(Saw setInterval with duration ' + duration + 'ms)');\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setInterval');\n\n    Timing.createTimer(id, duration || 0, Date.now(),\n    /* recurring */\n    true);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked before the end of the\n   * current JavaScript execution loop.\n   */\n\n  /* $FlowFixMe(>=0.79.1 site=react_native_fb) This comment suppresses an\n   * error found when Flow v0.79 was deployed. To see the error delete this\n   * comment and run Flow. */\n  setImmediate: function setImmediate(func) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setImmediate');\n\n    immediates.push(id);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame.\n   */\n\n  /* $FlowFixMe(>=0.79.1 site=react_native_fb) This comment suppresses an\n   * error found when Flow v0.79 was deployed. To see the error delete this\n   * comment and run Flow. */\n  requestAnimationFrame: function requestAnimationFrame(func) {\n    var id = _allocateCallback(func, 'requestAnimationFrame');\n\n    Timing.createTimer(id, 1, Date.now(),\n    /* recurring */\n    false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame and provided\n   * with time remaining in frame.\n   * @param {?object} options\n   */\n\n  /* $FlowFixMe(>=0.79.1 site=react_native_fb) This comment suppresses an\n   * error found when Flow v0.79 was deployed. To see the error delete this\n   * comment and run Flow. */\n  requestIdleCallback: function requestIdleCallback(func, options) {\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(true);\n    }\n\n    var timeout = options && options.timeout;\n\n    var id = _allocateCallback(timeout != null ? function (deadline) {\n      var timeoutId = requestIdleCallbackTimeouts[id];\n\n      if (timeoutId) {\n        JSTimers.clearTimeout(timeoutId);\n        delete requestIdleCallbackTimeouts[id];\n      }\n\n      return func(deadline);\n    } : func, 'requestIdleCallback');\n\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      var timeoutId = JSTimers.setTimeout(function () {\n        var index = requestIdleCallbacks.indexOf(id);\n\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n\n          _callTimer(id, performanceNow(), true);\n        }\n\n        delete requestIdleCallbackTimeouts[id];\n\n        if (requestIdleCallbacks.length === 0) {\n          Timing.setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n\n    return id;\n  },\n  cancelIdleCallback: function cancelIdleCallback(timerID) {\n    _freeCallback(timerID);\n\n    var index = requestIdleCallbacks.indexOf(timerID);\n\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    var timeoutId = requestIdleCallbackTimeouts[timerID];\n\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n  },\n  clearTimeout: function clearTimeout(timerID) {\n    _freeCallback(timerID);\n  },\n  clearInterval: function clearInterval(timerID) {\n    _freeCallback(timerID);\n  },\n  clearImmediate: function clearImmediate(timerID) {\n    _freeCallback(timerID);\n\n    var index = immediates.indexOf(timerID);\n\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n  cancelAnimationFrame: function cancelAnimationFrame(timerID) {\n    _freeCallback(timerID);\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers: function callTimers(timersToCall) {\n    invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.'); // $FlowFixMe: optionals do not allow assignment from null\n\n    errors = null;\n\n    for (var i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    if (errors) {\n      var errorCount = errors.length;\n\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (var ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(function (error) {\n            throw error;\n          }.bind(null, errors[ii]), 0);\n        }\n      }\n\n      throw errors[0];\n    }\n  },\n  callIdleCallbacks: function callIdleCallbacks(frameTime) {\n    if (FRAME_DURATION - (performanceNow() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    } // $FlowFixMe: optionals do not allow assignment from null\n\n\n    errors = null;\n\n    if (requestIdleCallbacks.length > 0) {\n      var passIdleCallbacks = requestIdleCallbacks.slice();\n      requestIdleCallbacks = [];\n\n      for (var i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n\n    if (errors) {\n      errors.forEach(function (error) {\n        return JSTimers.setTimeout(function () {\n          throw error;\n        }, 0);\n      });\n    }\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates: function callImmediates() {\n    errors = null;\n\n    while (_callImmediatesPass()) {}\n\n    if (errors) {\n      errors.forEach(function (error) {\n        return JSTimers.setTimeout(function () {\n          throw error;\n        }, 0);\n      });\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  }\n};\nvar ExportedJSTimers;\n\nif (!Timing) {\n  console.warn(\"Timing native module is not available, can't set timers.\"); // $FlowFixMe: we can assume timers are generally available\n\n  ExportedJSTimers = {\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate\n  };\n} else {\n  ExportedJSTimers = JSTimers;\n}\n\nBatchedBridge.setImmediatesCallback(ExportedJSTimers.callImmediates.bind(ExportedJSTimers));\nmodule.exports = JSTimers;\n\n//# sourceURL=webpack:///./Core/Timers/JSTimers.js?");

/***/ }),

/***/ "./Performance/Systrace.js":
/*!*********************************!*\
  !*** ./Performance/Systrace.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n\nvar invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar TRACE_TAG_REACT_APPS = 1 << 17; // eslint-disable-line no-bitwise\n\nvar TRACE_TAG_JS_VM_CALLS = 1 << 27; // eslint-disable-line no-bitwise\n\nvar _enabled = false;\nvar _asyncCookie = 0;\nvar _markStack = [];\n\nvar _markStackIndex = -1;\n\nvar _canInstallReactHook = false; // Implements a subset of User Timing API necessary for React measurements.\n// https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API\n\nvar REACT_MARKER = \"\\u269B\";\nvar userTimingPolyfill = __DEV__ ? {\n  mark: function mark(markName) {\n    if (_enabled) {\n      _markStackIndex++;\n      _markStack[_markStackIndex] = markName;\n      var systraceLabel = markName; // Since perf measurements are a shared namespace in User Timing API,\n      // we prefix all React results with a React emoji.\n\n      if (markName[0] === REACT_MARKER) {\n        // This is coming from React.\n        // Removing component IDs keeps trace colors stable.\n        var indexOfId = markName.lastIndexOf(' (#');\n        var cutoffIndex = indexOfId !== -1 ? indexOfId : markName.length; // Also cut off the emoji because it breaks Systrace\n\n        systraceLabel = markName.slice(2, cutoffIndex);\n      }\n\n      Systrace.beginEvent(systraceLabel);\n    }\n  },\n  measure: function measure(measureName, startMark, endMark) {\n    if (_enabled) {\n      invariant(typeof measureName === 'string' && typeof startMark === 'string' && typeof endMark === 'undefined', 'Only performance.measure(string, string) overload is supported.');\n      var topMark = _markStack[_markStackIndex];\n      invariant(startMark === topMark, 'There was a mismatching performance.measure() call. ' + 'Expected \"%s\" but got \"%s.\"', topMark, startMark);\n      _markStackIndex--; // We can't use more descriptive measureName because Systrace doesn't\n      // let us edit labels post factum.\n\n      Systrace.endEvent();\n    }\n  },\n  clearMarks: function clearMarks(markName) {\n    if (_enabled) {\n      if (_markStackIndex === -1) {\n        return;\n      }\n\n      if (markName === _markStack[_markStackIndex]) {\n        // React uses this for \"cancelling\" started measurements.\n        // Systrace doesn't support deleting measurements, so we just stop them.\n        if (userTimingPolyfill != null) {\n          userTimingPolyfill.measure(markName, markName);\n        }\n      }\n    }\n  },\n  clearMeasures: function clearMeasures() {// React calls this to avoid memory leaks in browsers, but we don't keep\n    // measurements anyway.\n  }\n} : null;\nvar Systrace = {\n  installReactHook: function installReactHook() {\n    if (_enabled) {\n      if (__DEV__) {\n        global.performance = userTimingPolyfill;\n      }\n    }\n\n    _canInstallReactHook = true;\n  },\n  setEnabled: function setEnabled(enabled) {\n    if (_enabled !== enabled) {\n      if (__DEV__) {\n        if (enabled) {\n          global.nativeTraceBeginLegacy && global.nativeTraceBeginLegacy(TRACE_TAG_JS_VM_CALLS);\n        } else {\n          global.nativeTraceEndLegacy && global.nativeTraceEndLegacy(TRACE_TAG_JS_VM_CALLS);\n        }\n\n        if (_canInstallReactHook) {\n          if (enabled && global.performance === undefined) {\n            global.performance = userTimingPolyfill;\n          }\n        }\n      }\n\n      _enabled = enabled;\n    }\n  },\n  isEnabled: function isEnabled() {\n    return _enabled;\n  },\n\n  /**\n   * beginEvent/endEvent for starting and then ending a profile within the same call stack frame\n   **/\n  beginEvent: function beginEvent(profileName, args) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);\n    }\n  },\n  endEvent: function endEvent() {\n    if (_enabled) {\n      global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);\n    }\n  },\n\n  /**\n   * beginAsyncEvent/endAsyncEvent for starting and then ending a profile where the end can either\n   * occur on another thread or out of the current stack frame, eg await\n   * the returned cookie variable should be used as input into the endAsyncEvent call to end the profile\n   **/\n  beginAsyncEvent: function beginAsyncEvent(profileName) {\n    var cookie = _asyncCookie;\n\n    if (_enabled) {\n      _asyncCookie++;\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);\n    }\n\n    return cookie;\n  },\n  endAsyncEvent: function endAsyncEvent(profileName, cookie) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);\n    }\n  },\n\n  /**\n   * counterEvent registers the value to the profileName on the systrace timeline\n   **/\n  counterEvent: function counterEvent(profileName, value) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceCounter && global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);\n    }\n  }\n}; // if (__DEV__) {\n//   // This is needed, because require callis in polyfills are not processed as\n//   // other files. Therefore, calls to `require('moduleId')` are not replaced\n//   // with numeric IDs\n//   // TODO(davidaurelio) Scan polyfills for dependencies, too (t9759686)\n//   (require: any).Systrace = Systrace;\n// }\n\nmodule.exports = Systrace;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./Performance/Systrace.js?");

/***/ }),

/***/ "./Utilities/Platform.js":
/*!*******************************!*\
  !*** ./Utilities/Platform.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n\nvar NativeModules = __webpack_require__(/*! ../BatchedBridge/NativeModules */ \"./BatchedBridge/NativeModules.js\");\n\nvar Platform = {\n  OS: 'android',\n\n  get Version() {\n    var constants = NativeModules.PlatformConstants;\n    return constants && constants.Version;\n  },\n\n  get isTesting() {\n    if (__DEV__) {\n      var constants = NativeModules.PlatformConstants;\n      return constants && constants.isTesting;\n    }\n\n    return false;\n  },\n\n  get isTV() {\n    var constants = NativeModules.PlatformConstants;\n    return constants && constants.uiMode === 'tv';\n  },\n\n  select: function select(spec) {\n    return 'android' in spec ? spec.android : spec[\"default\"];\n  }\n};\nmodule.exports = Platform;\n\n//# sourceURL=webpack:///./Utilities/Platform.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\n\nvar ExecutionEnvironment = {\n  canUseDOM: canUseDOM,\n  canUseWorkers: typeof Worker !== 'undefined',\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n  canUseViewport: canUseDOM && !!window.screen,\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\nmodule.exports = ExecutionEnvironment;\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/ExecutionEnvironment.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\n\n\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\n\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/emptyFunction.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/performance.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/performance.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ \"./node_modules/fbjs/lib/ExecutionEnvironment.js\");\n\nvar performance;\n\nif (ExecutionEnvironment.canUseDOM) {\n  performance = window.performance || window.msPerformance || window.webkitPerformance;\n}\n\nmodule.exports = performance || {};\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/performance.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/performanceNow.js":
/*!*************************************************!*\
  !*** ./node_modules/fbjs/lib/performanceNow.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\nvar performance = __webpack_require__(/*! ./performance */ \"./node_modules/fbjs/lib/performance.js\");\n\nvar performanceNow;\n/**\n * Detect if we can use `window.performance.now()` and gracefully fallback to\n * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now\n * because of Facebook's testing infrastructure.\n */\n\nif (performance.now) {\n  performanceNow = function performanceNow() {\n    return performance.now();\n  };\n} else {\n  performanceNow = function performanceNow() {\n    return Date.now();\n  };\n}\n\nmodule.exports = performanceNow;\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/performanceNow.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\n\nfunction printWarning(format) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var argIndex = 0;\n  var message = 'Warning: ' + format.replace(/%s/g, function () {\n    return args[argIndex++];\n  });\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    // --- Welcome to debugging React ---\n    // This error was thrown as a convenience so that you can use this stack\n    // to find the callsite that caused this warning to fire.\n    throw new Error(message);\n  } catch (x) {}\n}\n\nvar warning =  true ? function (condition, format) {\n  if (format === undefined) {\n    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n  }\n\n  if (!condition) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    printWarning.apply(void 0, [format].concat(args));\n  }\n} : undefined;\nmodule.exports = warning;\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/warning.js?");

/***/ }),

/***/ "./node_modules/invariant/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (true) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n//# sourceURL=webpack:///./node_modules/invariant/browser.js?");

/***/ }),

/***/ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js ***!
  \***********************************************************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\nvar UNKNOWN_FUNCTION = '<unknown>';\n/**\n * This parses the different stack traces and puts them into one format\n * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)\n */\n\nfunction parse(stackString) {\n  var lines = stackString.split('\\n');\n  return lines.reduce(function (stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n\n    return stack;\n  }, []);\n}\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n  var submatch = chromeEvalRe.exec(parts[2]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1]; // url\n\n    parts[3] = submatch[2]; // line\n\n    parts[4] = submatch[3]; // column\n  }\n\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null; // no column when eval\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(',') : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./polyfills/defineLazyObjectProperty.js":
/*!***********************************************!*\
  !*** ./polyfills/defineLazyObjectProperty.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n/**\n * Defines a lazily evaluated property on the supplied `object`.\n */\n\nfunction defineLazyObjectProperty(object, name, descriptor) {\n  var get = descriptor.get;\n  var enumerable = descriptor.enumerable !== false;\n  var writable = descriptor.writable !== false;\n  var value;\n  var valueSet = false;\n\n  function getValue() {\n    // WORKAROUND: A weird infinite loop occurs where calling `getValue` calls\n    // `setValue` which calls `Object.defineProperty` which somehow triggers\n    // `getValue` again. Adding `valueSet` breaks this loop.\n    if (!valueSet) {\n      // Calling `get()` here can trigger an infinite loop if it fails to\n      // remove the getter on the property, which can happen when executing\n      // JS in a V8 context.  `valueSet = true` will break this loop, and\n      // sets the value of the property to undefined, until the code in `get()`\n      // finishes, at which point the property is set to the correct value.\n      valueSet = true;\n      setValue(get());\n    }\n\n    return value;\n  }\n\n  function setValue(newValue) {\n    value = newValue;\n    valueSet = true;\n    Object.defineProperty(object, name, {\n      value: newValue,\n      configurable: true,\n      enumerable: enumerable,\n      writable: writable\n    });\n  }\n\n  Object.defineProperty(object, name, {\n    get: getValue,\n    set: setValue,\n    configurable: true,\n    enumerable: enumerable\n  });\n}\n\nmodule.exports = defineLazyObjectProperty;\n\n//# sourceURL=webpack:///./polyfills/defineLazyObjectProperty.js?");

/***/ }),

/***/ "./polyfills/error-guard.js":
/*!**********************************!*\
  !*** ./polyfills/error-guard.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @polyfill\n * @nolint\n */\nvar _inGuard = 0;\n/**\n * This is the error handler that is called when we encounter an exception\n * when loading a module. This will report any errors encountered before\n * ExceptionsManager is configured.\n */\n\nvar _globalHandler = function onError(e) {\n  throw e;\n};\n/**\n * The particular require runtime that we are using looks for a global\n * `ErrorUtils` object and if it exists, then it requires modules with the\n * error handler specified via ErrorUtils.setGlobalHandler by calling the\n * require function with applyWithGuard. Since the require module is loaded\n * before any of the modules, this ErrorUtils must be defined (and the handler\n * set) globally before requiring anything.\n */\n\n\nvar ErrorUtils = {\n  setGlobalHandler: function setGlobalHandler(fun) {\n    _globalHandler = fun;\n  },\n  getGlobalHandler: function getGlobalHandler() {\n    return _globalHandler;\n  },\n  reportError: function reportError(error) {\n    _globalHandler && _globalHandler(error);\n  },\n  reportFatalError: function reportFatalError(error) {\n    _globalHandler && _globalHandler(error, true);\n  },\n  applyWithGuard: function applyWithGuard(fun, context, args) {\n    try {\n      _inGuard++;\n      return fun.apply(context, args);\n    } catch (e) {\n      ErrorUtils.reportError(e);\n    } finally {\n      _inGuard--;\n    }\n\n    return null;\n  },\n  applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {\n    if (ErrorUtils.inGuard()) {\n      return fun.apply(context, args);\n    } else {\n      ErrorUtils.applyWithGuard(fun, context, args);\n    }\n\n    return null;\n  },\n  inGuard: function inGuard() {\n    return _inGuard;\n  },\n  guard: function guard(fun, name, context) {\n    if (typeof fun !== 'function') {\n      console.warn('A function must be passed to ErrorUtils.guard, got ', fun);\n      return null;\n    }\n\n    name = name || fun.name || '<generated guard>';\n\n    function guarded() {\n      return ErrorUtils.applyWithGuard(fun, context || this, arguments, null, name);\n    }\n\n    return guarded;\n  }\n};\nmodule.exports = ErrorUtils;\n\n//# sourceURL=webpack:///./polyfills/error-guard.js?");

/***/ }),

/***/ "./polyfills/stringifySafe.js":
/*!************************************!*\
  !*** ./polyfills/stringifySafe.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n\n/**\n * Tries to stringify with JSON.stringify and toString, but catches exceptions\n * (e.g. from circular objects) and always returns a string and never throws.\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction stringifySafe(arg) {\n  var ret;\n\n  var type = _typeof(arg);\n\n  if (arg === undefined) {\n    ret = 'undefined';\n  } else if (arg === null) {\n    ret = 'null';\n  } else if (type === 'string') {\n    ret = '\"' + arg + '\"';\n  } else if (type === 'function') {\n    try {\n      ret = arg.toString();\n    } catch (e) {\n      ret = '[function unknown]';\n    }\n  } else {\n    // Perform a try catch, just in case the object has a circular\n    // reference or stringify throws for some other reason.\n    try {\n      ret = JSON.stringify(arg);\n    } catch (e) {\n      if (typeof arg.toString === 'function') {\n        try {\n          ret = arg.toString();\n        } catch (E) {}\n      }\n    }\n  }\n\n  return ret || '[\"' + type + '\" failed to stringify]';\n}\n\nmodule.exports = stringifySafe;\n\n//# sourceURL=webpack:///./polyfills/stringifySafe.js?");

/***/ }),

/***/ "./test/index.js":
/*!***********************!*\
  !*** ./test/index.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _BatchedBridge_NativeModules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BatchedBridge/NativeModules */ \"./BatchedBridge/NativeModules.js\");\n/* harmony import */ var _BatchedBridge_NativeModules__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_BatchedBridge_NativeModules__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Core_Timers_JSTimers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Timers/JSTimers */ \"./Core/Timers/JSTimers.js\");\n/* harmony import */ var _Core_Timers_JSTimers__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Core_Timers_JSTimers__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * Created by sanyinchen on 19-11-24.\n *\n * @author sanyinchen\n * @version v0.1\n * @since 19-11-24\n */\n\n // const Timer = new JSTimers();\n\nglobal.NativeLog = _BatchedBridge_NativeModules__WEBPACK_IMPORTED_MODULE_0___default.a.NativeLog;\nNativeLog.log(\"hello world !\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./test/index.js?");

/***/ }),

/***/ 0:
/*!*****************************!*\
  !*** multi ./test/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./test/index.js */\"./test/index.js\");\n\n\n//# sourceURL=webpack:///multi_./test/index.js?");

/***/ })

/******/ });